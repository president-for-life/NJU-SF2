# 连锁商店管理系统（MSCS）软件详细设计描述文档

## 文档修改历史

| 修改人员 | 日期 | 修改原因 | 版本号 |
|:--------:| ---- | -------- | ------ |
|          |      |          |        |

## 1. 引言

### 1.1 编制目的

本报告详细完成对影院影片管理系统的详细设计，达到指导后续软件构造的目的，同时实现和测试人员及用户的沟通。

本报告面向开发人员、测试人员及最终用户而编写，是了解系统的导航。

### 1.2 词汇表

| 词汇名称 | 词汇含义 | 备注 |
|:--------:|:--------:|:----:|
|          |          |      |

### 1.3 参考资料

软件开发的技术基础 软件工程与计算（卷二） —— 罗斌、丁二玉、刘钦

## 2. 产品描述

参考影院影片管理系统用例文档和影院影片管理系统软件需求规格说明文档中对产品的概括描述。

## 3. 系统结构设计概述

参考影院影片管理系统概要设计文档中对系统体系结构设计的概述。

## 4. 结构视角

### 4.1 业务逻辑层的分解

业务逻辑层的开发包图参见软件体系结构文档图

#### 4.1.1 management模块

(1) 模块概述

...

(2) 整体结构

...

(3) 模块内部类的接口规范

...

(4) 业务逻辑层的动态模型

...

(5) 业务逻辑层的设计原理

...

#### 4.1.2 promotion模块

(1) 模块概述

...

(2) 整体结构

...

(3) 模块内部类的接口规范

...

(4) 业务逻辑层的动态模型

...

(5) 业务逻辑层的设计原理

...

#### 4.1.3 sales模块

(1) 模块概述

sales模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

sales模块的职责及接口参见软件系统结构描述文档。
...

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层为了增加灵活性，我们会添加接口。展示层和业务逻辑层之间，我们添加bl.sales.TicketService接口。

sales模块各个类的职责如下表所示。

| 模块          | 职责                           |
| ------------- | ------------------------------ |
| TicketServiceImpl | 负责实现提供电影票购买所需要的服务 |

...

(3) 模块内部类的接口规范

TicketServiceImpl的接口规范如下表所示。

<table>
<tr><td colspan="3"><center>提供的服务（供接口）</center></td></tr>

<tr><td rowspan="4">TicketServiceImpl.addTicket</td></tr>
<tr><td>语法</td><td>public ResponseVO addTicket(TicketForm ticketForm)</td></tr>
<tr><td>前置条件</td><td>无</td></tr>
<tr><td>后置条件</td><td>锁座</td></tr>

<tr><td rowspan="4">TicketServiceImpl.completeTicket</td></tr>
<tr><td>语法</td><td>public ResponseVO completeTicket(List<Integer> id, int couponId)</td></tr>
<tr><td>前置条件</td><td>无</td></tr>
<tr><td>后置条件</td><td>完成购票【不使用会员卡】：校验优惠券和根据优惠活动赠送优惠券</td></tr>

<tr><td rowspan="4">TicketServiceImpl.getBySchedule</td></tr>
<tr><td>语法</td><td>public ResponseVO getBySchedule(int scheduleId)</td></tr>
<tr><td>前置条件</td><td>无</td></tr>
<tr><td>后置条件</td><td>获得该场次的被锁座位和场次信息</td></tr>

<tr><td rowspan="4">TicketServiceImpl.getTicketByUser</td></tr>
<tr><td>语法</td><td>public ResponseVO getTicketByUser(int userId)</td></tr>
<tr><td>前置条件</td><td>无</td></tr>
<tr><td>后置条件</td><td>获得用户买过的票</td></tr>

<tr><td rowspan="4">TicketServiceImpl.completeByVIPCard</td></tr>
<tr><td>语法</td><td>public ResponseVO completeByVIPCard(List<Integer> id, int couponId)</td></tr>
<tr><td>前置条件</td><td>无</td></tr>
<tr><td>后置条件</td><td>完成购票【使用会员卡】：会员卡扣费、校验优惠券和根据优惠活动赠送优惠券</td></tr>

<tr><td rowspan="4">TicketServiceImpl.cancelTicket</td></tr>
<tr><td>语法</td><td>public ResponseVO cancelTicket(List<Integer> id)</td></tr>
<tr><td>前置条件</td><td>座位当前状态是"锁定中"</td></tr>
<tr><td>后置条件</td><td>取消锁座</td></tr>

<tr><td colspan="3"><center>需要的服务（需接口）</center></td></tr>
<tr><td colspan="1"><center>服务名</center></td><td colspan="2"><center>服务</center></td></tr>

<tr><td rowspan="4">TicketMapper.selectTicketsBySchedule</td></tr>
<tr><td>语法</td><td>public List<Ticket> selectTicketsBySchedule(int scheduleId)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>根据排片的场次号获取该场次被锁定的座位列表</td></tr>

<tr><td rowspan="4">ScheduleServiceForBl.getScheduleItemById</td></tr>
<tr><td>语法</td><td>public ScheduleItem getScheduleItemById(int id)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>根据排片的场次号获取排片信息条目</td></tr>

<tr><td rowspan="4">HallServiceForBl.getHallById</td></tr>
<tr><td>语法</td><td>public Hall getHallById(int id)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>根据影厅id获得该影厅的实例对象</td></tr>

<tr><td rowspan="4">ScheduleItem.getHallId</td></tr>
<tr><td>语法</td><td>public Integer getHallId()</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>获取当前场次信息条目中的影厅id</td></tr>

<tr><td rowspan="4">Hall.getRow</td></tr>
<tr><td>语法</td><td>public Integer getRow()</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>获取当前影厅中座位的总行数</td></tr>

<tr><td rowspan="4">Hall.getColumn</td></tr>
<tr><td>语法</td><td>public Integer getColumn()</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>获取当前影厅中座位的总列数</td></tr>

<tr><td rowspan="4">ScheduleWithSeatVO.setScheduleItem</td></tr>
<tr><td>语法</td><td>public void setScheduleItem(ScheduleItem scheduleItem)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>在场次座位信息对象中设置场次信息条目</td></tr>

<tr><td rowspan="4">ScheduleWithSeatVO.setSeats</td></tr>
<tr><td>语法</td><td>public void setSeats(int[][] seats)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>在场次座位信息对象中设置座位信息</td></tr>

<tr><td rowspan="4">ResponseVO.buildSuccess</td></tr>
<tr><td>语法</td><td>public static ResponseVO buildSuccess(Object content)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>返回构建成功的答复</td></tr>

<tr><td rowspan="4">ResponseVO.buildFailure</td></tr>
<tr><td>语法</td><td>public static ResponseVO buildFailure(String message)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>返回构建失败的答复</td></tr>
</table>
...

(4) 业务逻辑层的动态模型

...

(5) 业务逻辑层的设计原理

...

#### 4.1.4 statistics模块

(1) 模块概述

statistics 模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

statistics模块的职责及接口参见软件系统结构描述文档表。

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。

statistics模块各个类的职责如表所示。

表statistic

| 类                   | 职责                                 |
| -------------------- | ------------------------------------ |
| MovieLikeServicelmpl | 负责实现把电影标记为想看所需要的服务 |
| StatisticServicelmpl |                                      |

模块各个类的职责

(3) 模块内部类的接口规范

表 MovieLikeServicelmpl的接口规范

提供的服务（供接口）

<table>

<tr>
  <td rowspan="4">MovieServiceImpl.likeMovie</td>
</tr>
<tr>
  <td>语法</td>
  <td>public ResponseVO likeMovie(int userId, int movieId)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td>该电影资料已存在，用户未标记为想看</td>
</tr>
<tr>
  <td>后置条件</td>
  <td>保存一条想看记录</td>
</tr>

<tr>
  <td rowspan="4">MovieServiceImpl.unLikeMovie</td>
</tr>
<tr>
  <td>语法</td>
  <td>public ResponseVO unLikeMovie(int userId, int movieId)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td>该电影资料已存在，用户已标记为想看</td>
</tr>
<tr>
  <td>后置条件</td>
  <td>删去一条想看记录</td>
</tr>

<tr>
  <td rowspan="4">MovieServiceImpl.getCountOfLikes</td>
</tr>
<tr>

  <td>语法</td>
  <td>public ResponseVO getCountOfLikes(int movieId)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>返回某个电影的想看人数</td>
</tr>

<tr>
  <td rowspan="4">MovieServiceImpl.getLikeNumsGroupByDate</td>
</tr>
<tr>

  <td>语法</td>
  <td>public ResponseVO getLikeNumsGroupByDate(int movieId)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>返回某个电影的喜爱人数按日期统计</td>
</tr>

<tr>
  <td rowspan="4">MovieServiceImpl.userLikeTheMovie</td>
</tr>
<tr>

  <td>语法</td>
  <td>public ResponseVO userLikeTheMovie(int userId, int movieId)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>返回某个用户是否喜欢某个电影</td>
</tr>

  <td>语法</td>
  <td>public List<DateLikeVO>  dateLikeList2DateLikeVOList(int List<DateLike> dateLikeList)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>返回某段时间的各自的喜爱人数</td>
</tr>

</table>

需要的服务（需接口）

<table>

<tr>
  <td>服务名</td>
  <td>服务</td>
</tr>

<tr>
  <td>MovieServiceForBl.getMovieById(int id)</td>
  <td>根据id查找单一持久化对象</td>
</tr>

<tr>
  <td>MovieLikeMapper.insertOneLike(int movieId,int userId)</td>
  <td>插入单一持久化对象</td>
</tr>

<tr>
  <td>MovieLikeMapper.deleteOneLike(int movieId,int userId)</td>
  <td>删除单一持久化对象</td>
</tr>

<tr>
  <td>MovieLikeMapper.selectOneLike(int movieId)</td>
  <td>根据movieId查找单一持久化对象</td>
</tr>

<tr>
  <td>MovieLikeMapper.getDateLikeNum(int movieId)</td>
  <td>根据movieId查找多个持久化对象</td>
</tr>

<tr>
  <td>MovieLikeMapper.selectLikeMovie(int movieId,int userId)</td>
  <td>根据movieId和userId查找单一持久化对象</td>
</tr>

</table>

表 StatisticsServicelmpl的接口规范

提供的服务（供接口）

<table>

<tr>
  <td rowspan="4">StatisticsServicelmpl.getScheduleRateByDate</td>
</tr>
<tr>
  <td>语法</td>
  <td>public ResponseVO getScheduleRateByDate(Date date)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>获取某日影片排片率统计数据</td>
</tr>

<tr>
  <td rowspan="4">StatisticsServicelmpl.getTotalBoxOffice</td>
</tr>
<tr>
  <td>语法</td>
  <td>public ResponseVO getTotalBoxOffice()</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>获取所有电影的累计票房</td>
</tr>

<tr>
  <td rowspan="4">StatisticsServicelmpl.getAudiencePriceSevenDays</td>
</tr>
<tr>
  <td>语法</td>
  <td>public ResponseVO getAudiencePriceSevenDays()</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>获取过去七天内每天的客单价</td>
</tr>

<tr>
  <td rowspan="4">StatisticsServicelmpl.getMoviePlacingRateByDate</td>
</tr>
<tr>
  <td>语法</td>
  <td>public ResponseVO getMoviePlacingRateByDate(Date date)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>获取所有电影某天的上座率</td>
</tr>

<tr>
  <td rowspan="4">StatisticsServicelmpl.getPopularMovies</td>
</tr>
<tr>
  <td>语法</td>
  <td>public ResponseVO getPopularMovie(int days, int movieNum)</td>
</tr>
<tr>
  <td>前置条件</td>
  <td></td>
</tr>
<tr>
  <td>后置条件</td>
  <td>获取最近某些天内，最受欢迎的某些电影</td>
</tr>

</table>

(4) 业务逻辑层的动态模型

...

(5) 业务逻辑层的设计原理

...

#### 4.1.5 user模块

(1) 模块概述

user模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。

user模块的职责及接口参见软件系统结构描述文档表。
...

(2) 整体结构

根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。展示层和业务逻辑层之间，我们添加bl.。业务逻辑层和数据层之间添加？？？。

| 模块               | 职责 |
| ------------------ | ---- |
| AccountServiceImpl | 负责实现用户的注册登录所需要的服务     |
...

(3) 模块内部类的接口规范

<table>
<tr><td colspan="3"><center>提供的服务（供接口）</center></td></tr>

<tr><td rowspan="4">AccountServiceImpl.registerAccount</td></tr>
<tr><td>语法</td><td>public ResponseVO registerAccount(UserForm userForm)</td></tr>
<tr><td>前置条件</td><td>无</td></tr>
<tr><td>后置条件</td><td>完成用户注册</td></tr>

<tr><td rowspan="4">AccountServiceImpl.login</td></tr>
<tr><td>语法</td><td>public UserVO login(UserForm userForm)</td></tr>
<tr><td>前置条件</td><td>无</td></tr>
<tr><td>后置条件</td><td>完成用户登录</td></tr>

<tr><td colspan="3"><center>需要的服务（需接口）</center></td></tr>
<tr><td colspan="1"><center>服务名</center></td><td colspan="2"><center>服务</center></td></tr>

<tr><td rowspan="4">AccountMapper.createNewAccount</td></tr>
<tr><td>语法</td><td>public int createNewAccount(@Param("username") String username, @Param("password") String password);</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>创建一个新账户</td></tr>

<tr><td rowspan="4">AccountMapper.getAccountByName</td></tr>
<tr><td>语法</td><td>public User getAccountByName(@Param("username") String username)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>根据用户名获取该用户实例</td></tr>

<tr><td rowspan="4">UserForm.getUsername</td></tr>
<tr><td>语法</td><td>public String getUsername()</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>获取当前用户表单中用户输入的用户名</td></tr>

<tr><td rowspan="4">UserForm.getPassword</td></tr>
<tr><td>语法</td><td>ublic String getPassword()</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>获取当前用户表单中用户输入的密码</td></tr>

<tr><td rowspan="4">User.getPassword</td></tr>
<tr><td>语法</td><td>public String getPassword()</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>获取当前用户的正确密码</td></tr>

<tr><td rowspan="4">UserVO.UserVO</td></tr>
<tr><td>语法</td><td>public UserVO login(UserForm userForm)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>创建一个UserVO对象</td></tr>

<tr><td rowspan="4">ResponseVO.buildSuccess</td></tr>
<tr><td>语法</td><td>public static ResponseVO buildSuccess()</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>返回构建成功的答复</td></tr>

<tr><td rowspan="4">ResponseVO.buildFailure</td></tr>
<tr><td>语法</td><td>public static ResponseVO buildFailure(String message)</td></tr>
<tr><td>前置条件</td><td>？？？？</td></tr>
<tr><td>后置条件</td><td>返回构建失败的答复</td></tr>

</table>
...

(4) 业务逻辑层的动态模型

...

(5) 业务逻辑层的设计原理

...

## 5. 依赖视角
